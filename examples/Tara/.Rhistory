install.packages("glasso")
library("glasso", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
example(glasso)
example(glassopath)
a
a$wi
edit(glasso)
install.packages("~/Documents/Projects/TREX/RTrex/trexr_0.3.tar.gz", repos = NULL, type = "source")
install.packages("glmnet")
install.packages("lpSolve")
install.packages("~/Documents/Projects/TREX/RTrex/trexr_0.3.tar.gz", repos = NULL, type = "source")
example(trex)
examples(trex)
?trex
?trexr
examples(trexr)
install.packages(c("boot", "class", "cluster", "codetools", "KernSmooth", "MASS", "mgcv"))
load(trex)
load(trexr)
load("trexr")
trexr
load("trexr")
load("trex")
detach("package:glasso", unload=TRUE)
library("glasso", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
dir
dir()
cd("Documents/Projects/TREX/RTrex/")
library(trexr)
install.packages("R.matlab")
install.packages("huge")
library(huge)
detach("package:glasso", unload=TRUE)
library("glasso", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
library("glmnet", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
library("lpSolve", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
library("R.matlab", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
?trex
example(trex)
fit2 = trex.linesearch(x, y)
fit2$obj
fit2$best.obj
fit$best.obj
y = x %*% beta + 0.1 * rnorm(n)
fit2 = trex.linesearch(x, y)
example(trex)
n=50
p=50
x = matrix(rnorm(n * p), n, p)
xnorms = sqrt(colSums(x^2))
x = t(t(x) / xnorms) * sqrt(n) # scale columns
beta = rep(0, p)
beta[1:4] = 1
y = x %*% beta + 0.1 * rnorm(n)
fit2 = trex.linesearch(x,y)
fit = trex(x,y)
fit2$betahat
fit$betahat
.libPaths
.libPaths()
open("/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
library("yeastExpData")
install.packages("yeastExpData")
source("http://bioconductor.org/biocLite.R")
biocLite("yeastExpData")
browseVignettes("yeastExpData")
data(litG)
library("yeastExpData")
data("litG")
writeMat("litG.mat",litG=litG)
litG
litG
litG(edge)
ppinodes = nodes(litG)
ppiedges = edges(litG)
writeMat("ppinodes.mat",ppinodes=ppinodes)
writeMat("ppiedges.mat",ppiedges=ppiedges)
dir()
install.packages("pulsar")
library("pulsar", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
ls
dir
dir()
p <- 40
n <- round(8*p * log(p))
library(huge)
set.seed(10010)
dat <- huge.generator(n, p, 'hub', verbose=FALSE, v=.3, u=.1)
install.packages("huge")
install.packages(c("mgcv", "survival"))
install.packages("huge")
library("huge", lib.loc="/Library/Frameworks/R.framework/Versions/3.3/Resources/library")
library(MASS)
source('~/Desktop/pulsarTest.R')
lams <- getLamPath(lmax, lmax*.05, len=40)
lams
install.packages("graph")
install.packages("graph")
source('~/Desktop/pulsarTest.R')
fit.p    <- refit(out.p)
out.p
install.packages("glmnet")
source('~/Desktop/pulsarTest.R')
qmp
load("/Users/cmueller/Downloads/sCD14.rda")
View(sCD14)
load("/Users/cmueller/Library/Containers/com.apple.mail/Data/Library/Mail Downloads/5E3DBAB6-1E44-41E3-A7B9-500F95A7D428/Data_HIV.RData")
usepackage(phyloseq)
package(phyloseq)
devtools::install_git("amishra-simonsfoundation/robregcc/robregcc")
devtools::install_github("amishra-simonsfoundation/robregcc/robregcc")
devtools::install_github("amishra-simonsfoundation/robregcc/robregcc")
devtools::install_github("amishra-simonsfoundation/robregcc/robregcc")
devtools::install_github("amishra-simonsfoundation/robregcc/robregcc")
devtools::install_github("amishra-simonsfoundation/robregcc/robregcc")
devtools::install_github("amishra-simonsfoundation/robregcc/robregcc")
devtools::install_github("amishra-simonsfoundation/robregcc/robregcc")
devtools::install_github("simonscmap/cmap4r/package/cmap4r")
set_authorization()
library(cmap4r)
library(cmap4r)
ggplot2
update.packages(ggplot2)
update.packages("ggplot2")
library(cmap4r)
update.packages("rlang")
library(cmap4r)
devtools::install_github("r-lib/rlang", build_vignettes = TRUE)
library(cmap4r)
library(cmap4r)
devtools::install_github("simonscmap/cmap4r/package/cmap4r")
set_authorization()
library(cmap4r)
set_authorization()
set_authorization()
library(ebimetagenomics)
library(ebimetagenomics)
install.packages("ebimetagenomics", repos="http://R-Forge.R-project.org")
library(ebimetagenomics)
install.packages("ebimetagenomics", repos="http://R-Forge.R-project.org")
library(ebimetagenomics)
library(ebimetagenomics)
install.packages("ebimetagenomics")
install.packages("ebimetagenomics")
setwd("~/Dropbox (Simons Foundation)/magg/data/Tara")
tara <- readRDS("tara_10.RDS")
sample_data(tara)
sample_data(tara)$Marine.pelagic.biomes..Longhurst.2007
sample_data(tara)$Marine.pelagic.biomes..Longhurst.2007.
# Longhurst provinces in Longhurst
sample_data(tara)$Marine.pelagic.biomes..Longhurst.2007.
tax <- tara@tax_table@.Data
sample_data(tara)$Marine.pelagic.biomes..Longhurst.2007.
setwd("~/Dropbox (Simons Foundation)/magg/data/Tara")
library(phyloseq)
library(Matrix)
library(tidyverse)
library(trac)
tara <- readRDS("tara_10.RDS")
# Use salinity as outcome
y <- sample_data(tara)$Mean_Salinity..PSU.
summary(y)
keep <- which(!is.na(sample_data(tara)$Mean_Salinity..PSU.))
# Longhurst provinces in Longhurst
sample_data(tara)$Marine.pelagic.biomes..Longhurst.2007.
tax <- tara@tax_table@.Data
# replace "unclassified" with the appropriate blank tag
blank <- paste0(c("k", "p", "c", "o", "f", "g", "s"), "__")
for (i in 1:7) tax[tax[, i] == "unclassified", i] <- blank[i]
for (i in 1:7) tax[tax[, i] == "undef", i] <- blank[i]
for (i in 1:7) tax[tax[, i] == "", i] <- blank[i]
tax <- cbind("Life", tax); colnames(tax)[1] <- "Rank0"
# add an OTU column
tax <- cbind(tax, rownames(tax))
colnames(tax)[ncol(tax)] <- "OTU"
colnames(tax)[(colnames(tax) == "OTU.rep")] <- "Species"
colnames(tax)[(colnames(tax) == "Domain")] <- "Kingdom"
# make it so labels are unique
for (i in seq(2, 8)) {
# add a number when the type is unknown... e.g. "g__"
ii <- nchar(tax[, i]) == 3
if (sum(ii) > 0)
tax[ii, i] <- paste0(tax[ii, i], 1:sum(ii))
}
# cumulative labels are harder to read but easier to work with:
for (i in 2:9) {
tax[, i] <- paste(tax[, i-1], tax[, i], sep = "::")
}
tax <- as.data.frame(tax)
# form phylo object:
tree1 <- tax_table_to_phylo(~Rank0/Kingdom/Phylum/Class/Order/Family/Genus/Species/OTU,
data = tax, collapse = TRUE)
# convert this to an A matrix to be used for aggregation:
A <- phylo_to_A(tree1)
dat <- list(y = y[keep],
x = t(tara@otu_table@.Data)[keep,],
tree = tree1,
tax = tax,
A = A,
sample_data = as_tibble(sample_data(tara)[keep,]))
# rows of A correspond to OTUs as do columns of x
# rearrange columns of x to be in the order of rows of A:
dat$x <- dat$x[, match(str_match(rownames(A), "::([^:]+)$")[, 2],
colnames(dat$x))]
identical(str_match(rownames(A), "::([^:]+)$")[,2],
colnames(dat$x))
sample_data(tara)$
ds
sample_data(tara)
colNames(sample_data(tara))
colnames(sample_data(tara))
# Use diversity as outcome
y <- sample_data(tara)$Shannon.diversity.index.
summary(y)
keep <- which(!is.na(sample_data(tara)$Mean_Salinity..PSU.))
dat <- list(y = y[keep],
x = t(tara@otu_table@.Data)[keep,],
tree = tree1,
tax = tax,
A = A,
sample_data = as_tibble(sample_data(tara)[keep,]))
# rows of A correspond to OTUs as do columns of x
# rearrange columns of x to be in the order of rows of A:
dat$x <- dat$x[, match(str_match(rownames(A), "::([^:]+)$")[, 2],
colnames(dat$x))]
identical(str_match(rownames(A), "::([^:]+)$")[,2],
colnames(dat$x))
saveRDS(dat, file = "tara_div_processed.RDS")
library(Matrix)
library(tidyverse)
# Enforce a certain Python installation in Christian's setup
library(reticulate)
# conda activate r-reticulate
use_python("~/.conda/envs/classo/bin/python",required = TRUE)
library(trac)
dat <- readRDS("tara_div_processed.RDS")
#set.seed(2342)
set.seed(123)
ntot <- length(dat$y)
n <- round(2/3 * ntot)
tr <- sample(ntot, n)
ytr <- dat$y[tr]
yte <- dat$y[-tr]
log_pseudo <- function(x, pseudo_count = 1) log(x + pseudo_count)
ztr <- log_pseudo(dat$x[tr, ])
zte <- log_pseudo(dat$x[-tr, ])
fit <- trac(ztr, ytr, dat$A, w = NULL, min_frac = 1e-3)
yhat_te <- predict_trac(fit, new_Z = zte)
testerr <- colMeans((yhat_te[[1]] - yte)^2)
plot(testerr)
cvfit <- cv_trac(fit, Z = ztr, y = ytr, A = dat$A)
plot_cv_trac(cvfit)
#save(tr, ytr, yte, ztr, zte, cvfit, fit, file = "tara_div_trac.Rdata")
#load("tara_div_trac.Rdata")
gamma_cvbest <- round(fit[[1]]$gamma[, cvfit$cv[[1]]$ibest], 6)
gamma_cv1se <- round(fit[[1]]$gamma[, cvfit$cv[[1]]$i1se], 6)
gamma_cvbest[gamma_cvbest != 0]
gamma_cv1se[gamma_cv1se != 0]
# Best by test error
gamma_best <- round(fit[[1]]$gamma[, 15], 6)
gamma_best[gamma_best != 0]
tax_levels <- c("Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "OTU")
selected <- enframe(gamma_cv1se) %>%
separate(name,
into = c(NA, tax_levels),
sep = "::",
remove = FALSE,
fill = "right") %>%
filter(value != 0)
# arrange by taxonomy:
selected %>%
arrange(!!!rlang::syms(tax_levels)) %>%
select(-name) %>%
mutate_all(~ replace_na(., "")) %>% View()
# how many aggregated at each level?
tax_levels <- factor(tax_levels, levels = tax_levels)
table(tax_levels[1 + selected$name %>% str_count("::")])
# test error for chosen lam1
yhat_te <- predict_trac(fit, new_Z = zte)
ilam_best <- cvfit$cv[[1]]$ibest
ilam_1se <- cvfit$cv[[1]]$i1se
testerr <- colMeans((yhat_te[[1]] - yte)^2)
plot(testerr)
abline(v = c(ilam_best, ilam_1se))
testerr[ilam_best] # test error at CV-best
plot(yhat_te[[1]][,ilam_best],yte)
abline(0,1)
cor(yhat_te[[1]][,ilam_best],yte)
yhat_tr <- predict_trac(fit, new_Z = ztr)
plot(yhat_tr[[1]][,ilam_best],ytr)
abline(0,1)
cor(yhat_tr[[1]][,ilam_best],ytr)
plot(yhat_te[[1]][,ilam_1se],yte)
abline(0,1)
cor(yhat_te[[1]][,ilam_1se],yte)
yhat_tr <- predict_trac(fit, new_Z = ztr)
plot(yhat_tr[[1]][,ilam_1se],ytr)
abline(0,1)
cor(yhat_tr[[1]][,ilam_1se],ytr)
library(phyloseq)
load("taraData.rda")
tara  <- physeq
map <- data.frame(metadata, row.names=metadata$SampleName)
sample_data(tara) <- map ## assign metadata to phyloseq object
tara
badTaxa = c("OTU1") # undefined across all ranks
allTaxa = taxa_names(tara)
allTaxa <- allTaxa[!(allTaxa %in% badTaxa)]
tara = prune_taxa(allTaxa, tara)
depths <- colSums(tara@otu_table@.Data) ## calculate sequencing depths
## Pruning (Minimum sequencing depth: at least 10000 reads per sample)
tara.filt1 <- prune_samples(depths > 10000, tara)
tara.filt1
## Pruning (taxa present in at least 10% of samples)
tara.filt4 <- prune_taxa(freq > 0.1 * nsamples(tara.filt1), tara.filt1)
tara.filt4
## Pruning (taxa present in at least 10% of samples)
tara.filt4 <- prune_taxa(freq > 0.1 * nsamples(tara.filt1), tara.filt1)
## Pruning (taxa present in at least 1% of samples)
freq <- rowSums(sign(tara.filt1@otu_table@.Data))
## Pruning (taxa present in at least 10% of samples)
tara.filt4 <- prune_taxa(freq > 0.1 * nsamples(tara.filt1), tara.filt1)
tara.filt4
